#!/bin/bash
# SCRIPT: test
# DESCRIPTION: Run Nomisma tests using Docker containers
# USAGE: ./test [-t backend|frontend|e2e|api] [-i image_path] [-h]
# PARAMETERS:
#   -t    Test type to run (backend, frontend, e2e, api)
#   -i    Image path for Gemini analysis (api test only)
#   -h    Display this help message
# EXAMPLE: ./test -t backend
# EXAMPLE: ./test -t api -i /path/to/image.jpg

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Check if script-helpers is installed
if [ ! -f "${SCRIPT_DIR}/.script-helpers/helpers.sh" ]; then
    echo "⚠️  Warning: script-helpers not found"
    echo "This script requires the script-helpers library."
    echo ""
    echo "To install it, run:"
    echo "  ./update"
    echo ""
    read -p "Would you like to run ./update now? (y/n): " response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        "${SCRIPT_DIR}/update"
        echo ""
        echo "Please run ./test again"
        exit 0
    else
        echo "Exiting. Please run ./update before using this script."
        exit 1
    fi
fi

source "${SCRIPT_DIR}/.script-helpers/helpers.sh"
shlib_import logging help

TEST_TYPE="all"
IMAGE_PATH=""

while getopts "ht:i:" opt; do
    case $opt in
        h)
            display_help "$0"
            exit 0
            ;;
        t)
            TEST_TYPE="$OPTARG"
            ;;
        i)
            IMAGE_PATH="$OPTARG"
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            echo "Use -h for help"
            exit 1
            ;;
    esac
done

case "$TEST_TYPE" in
    all|backend|frontend|e2e|api) ;;
    *)
        log_error "Invalid test type: $TEST_TYPE"
        log_info "Valid types: backend, frontend, e2e, api"
        exit 1
        ;;
esac

if [ -n "$IMAGE_PATH" ] && [ "$TEST_TYPE" != "api" ]; then
    log_error "Image path (-i) is only supported with -t api"
    exit 1
fi

if ! command -v docker &> /dev/null; then
    log_error "Docker is not installed"
    exit 1
fi

if command -v docker-compose &> /dev/null; then
    COMPOSE_CMD=(docker-compose)
elif docker compose version &> /dev/null; then
    COMPOSE_CMD=(docker compose)
else
    log_error "Docker Compose not found"
    exit 1
fi

PROJECT_NAME="${COMPOSE_PROJECT_NAME:-$(basename "$SCRIPT_DIR")}"
COMPOSE_NETWORK="${PROJECT_NAME}_default"

BACKEND_RESULTS="${SCRIPT_DIR}/backend/.test-results"
FRONTEND_RESULTS="${SCRIPT_DIR}/frontend/.test-results"
mkdir -p "$BACKEND_RESULTS" "$FRONTEND_RESULTS"

STARTED_SERVICES=()

track_service() {
    local service="$1"
    local existing

    for existing in "${STARTED_SERVICES[@]}"; do
        if [ "$existing" = "$service" ]; then
            return 0
        fi
    done

    STARTED_SERVICES+=("$service")
}

service_is_running() {
    local service="$1"
    local id

    id=$(${COMPOSE_CMD[@]} ps -q "$service")
    if [ -z "$id" ]; then
        return 1
    fi

    local running
    running=$(docker inspect -f '{{.State.Running}}' "$id" 2>/dev/null || echo "false")
    [ "$running" = "true" ]
}

ensure_service_running() {
    local service="$1"

    if service_is_running "$service"; then
        return 0
    fi

    log_info "Starting $service for tests..."
    ${COMPOSE_CMD[@]} up -d "$service"
    track_service "$service"
}

wait_for_db() {
    local id
    id=$(${COMPOSE_CMD[@]} ps -q db)
    if [ -z "$id" ]; then
        return 1
    fi

    for _ in {1..30}; do
        local status
        status=$(docker inspect -f '{{.State.Health.Status}}' "$id" 2>/dev/null || echo "")
        if [ "$status" = "healthy" ]; then
            return 0
        fi
        sleep 2
    done

    return 1
}

wait_for_backend() {
    for _ in {1..30}; do
        if ${COMPOSE_CMD[@]} exec -T backend python - <<'PY'
import httpx

try:
    response = httpx.get("http://localhost:8000/health", timeout=2)
except Exception:
    raise SystemExit(1)

if response.status_code != 200:
    raise SystemExit(1)
PY
        then
            return 0
        fi
        sleep 2
    done

    return 1
}

wait_for_frontend() {
    for _ in {1..30}; do
        if ${COMPOSE_CMD[@]} exec -T backend python - <<'PY'
import httpx

try:
    response = httpx.get("http://frontend", timeout=2)
except Exception:
    raise SystemExit(1)

if response.status_code != 200:
    raise SystemExit(1)
PY
        then
            return 0
        fi
        sleep 2
    done

    return 1
}

copy_image_to_backend() {
    local source_path="$1"
    local dest_name="$2"
    local id

    id=$(${COMPOSE_CMD[@]} ps -q backend)
    if [ -z "$id" ]; then
        log_error "Backend container not found"
        exit 1
    fi

    docker cp "$source_path" "${id}:/app/images/$dest_name"
}

ensure_gemini_api_key() {
    if ! ${COMPOSE_CMD[@]} exec -T backend sh -lc 'test -n "$GEMINI_API_KEY"'; then
        log_error "GEMINI_API_KEY is not set for the backend container"
        exit 1
    fi
}

get_api_token() {
    local username="$1"
    local password="$2"
    local email="$3"
    local register_body
    local register_code
    local login_body
    local login_code
    local token

    register_body="$(mktemp)"
    login_body="$(mktemp)"

    register_code=$(curl -sS -o "$register_body" -w "%{http_code}" \
        -X POST "http://localhost:8000/api/auth/register" \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"$username\",\"email\":\"$email\",\"password\":\"$password\"}")

    if [ "$register_code" -ne 201 ] && [ "$register_code" -ne 400 ]; then
        log_error "Failed to register test user (status $register_code)"
        cat "$register_body"
        rm -f "$register_body" "$login_body"
        exit 1
    fi

    login_code=$(curl -sS -o "$login_body" -w "%{http_code}" \
        -X POST "http://localhost:8000/api/auth/login" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        --data-urlencode "username=$username" \
        --data-urlencode "password=$password")

    if [ "$login_code" -ne 200 ]; then
        log_error "Failed to log in test user (status $login_code)"
        cat "$login_body"
        rm -f "$register_body" "$login_body"
        exit 1
    fi

    token=$(jq -r '.access_token // empty' "$login_body")
    rm -f "$register_body" "$login_body"

    if [ -z "$token" ] || [ "$token" = "null" ]; then
        log_error "Login succeeded but no access token returned"
        exit 1
    fi

    echo "$token"
}

stop_started_services() {
    if [ ${#STARTED_SERVICES[@]} -eq 0 ]; then
        return 0
    fi

    log_info "Stopping test services..."
    ${COMPOSE_CMD[@]} stop "${STARTED_SERVICES[@]}"
}

trap stop_started_services EXIT

run_backend_tests() {
    log_info "Running backend tests..."
    ensure_service_running db

    if ! wait_for_db; then
        log_error "Database did not become healthy in time"
        exit 1
    fi

    ${COMPOSE_CMD[@]} run --rm -T backend pytest | tee "$BACKEND_RESULTS/pytest.txt"
}

run_frontend_tests() {
    log_info "Running frontend unit tests..."

    docker run --rm \
        -v "${SCRIPT_DIR}/frontend:/app" \
        -w /app \
        node:18-alpine \
        sh -lc "npm install && npm run test -- --run" | tee "$FRONTEND_RESULTS/vitest.txt"
}

run_e2e_tests() {
    log_info "Running E2E tests..."

    local db_running backend_running frontend_running
    db_running=$(service_is_running db && echo "true" || echo "false")
    backend_running=$(service_is_running backend && echo "true" || echo "false")
    frontend_running=$(service_is_running frontend && echo "true" || echo "false")

    ${COMPOSE_CMD[@]} up -d --build db backend frontend

    if [ "$db_running" = "false" ]; then
        track_service "db"
    fi
    if [ "$backend_running" = "false" ]; then
        track_service "backend"
    fi
    if [ "$frontend_running" = "false" ]; then
        track_service "frontend"
    fi

    if ! wait_for_db; then
        log_error "Database did not become healthy in time"
        exit 1
    fi
    if ! wait_for_backend; then
        log_error "Backend did not become ready in time"
        exit 1
    fi
    if ! wait_for_frontend; then
        log_error "Frontend did not become ready in time"
        exit 1
    fi

    docker run --rm \
        -v "${SCRIPT_DIR}/frontend:/app" \
        -w /app \
        --network "$COMPOSE_NETWORK" \
        -e E2E_BASE_URL="http://frontend" \
        -e API_BASE_URL="http://backend:8000" \
        mcr.microsoft.com/playwright:v1.41.2-jammy \
        sh -lc "npm install && npx playwright test --reporter=line" | tee "$FRONTEND_RESULTS/playwright.txt"
}

run_api_tests() {
    log_info "Running API health check..."
    ensure_service_running db
    ensure_service_running backend

    if ! wait_for_db; then
        log_error "Database did not become healthy in time"
        exit 1
    fi
    if ! wait_for_backend; then
        log_error "Backend did not become ready in time"
        exit 1
    fi

    ${COMPOSE_CMD[@]} exec -T backend python - <<'PY' | tee "$BACKEND_RESULTS/api.txt"
import httpx

response = httpx.get("http://localhost:8000/health", timeout=5)
print(response.status_code)
print(response.json())

if response.status_code != 200 or response.json() != {"status": "healthy"}:
    raise SystemExit(1)
PY

    if [ -z "$IMAGE_PATH" ]; then
        return 0
    fi

    if [ ! -f "$IMAGE_PATH" ]; then
        log_error "Image path not found: $IMAGE_PATH"
        exit 1
    fi

    if ! command -v jq &> /dev/null; then
        log_error "jq is required for API analysis output"
        exit 1
    fi

    ensure_gemini_api_key

    local image_name
    local user_seed
    local token
    local analysis_body
    local analysis_code

    image_name="$(date +%s)_$(basename "$IMAGE_PATH")"
    copy_image_to_backend "$IMAGE_PATH" "$image_name"

    user_seed="$(date +%s)_${RANDOM}_$$"
    token=$(get_api_token "test_user_$user_seed" "test_password_$user_seed" "test_$user_seed@example.com")

    analysis_body="$(mktemp)"
    analysis_code=$(curl -sS -o "$analysis_body" -w "%{http_code}" \
        -X POST "http://localhost:8000/api/ai/analyze" \
        -H "Authorization: Bearer $token" \
        -H "Content-Type: application/json" \
        -d "{\"image_path\":\"$image_name\"}")

    if [ "$analysis_code" -ne 200 ]; then
        log_error "Gemini analysis failed (status $analysis_code)"
        cat "$analysis_body"
        rm -f "$analysis_body"
        exit 1
    fi

    log_info "Gemini analysis result:"
    jq . "$analysis_body" | tee "$BACKEND_RESULTS/gemini_analysis.json"
    rm -f "$analysis_body"
}

if [ "$TEST_TYPE" = "all" ] || [ "$TEST_TYPE" = "backend" ]; then
    run_backend_tests
fi

if [ "$TEST_TYPE" = "all" ] || [ "$TEST_TYPE" = "frontend" ]; then
    run_frontend_tests
fi

if [ "$TEST_TYPE" = "all" ] || [ "$TEST_TYPE" = "api" ]; then
    run_api_tests
fi

if [ "$TEST_TYPE" = "all" ] || [ "$TEST_TYPE" = "e2e" ]; then
    run_e2e_tests
fi

log_info "Tests complete"
